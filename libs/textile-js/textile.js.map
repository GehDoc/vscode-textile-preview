{"version":3,"sources":["webpack://textile/webpack/universalModuleDefinition","webpack://textile/webpack/bootstrap","webpack://textile/./src/re.js","webpack://textile/./src/ribbon.js","webpack://textile/./src/textile/attr.js","webpack://textile/./src/html.js","webpack://textile/./src/textile/phrase.js","webpack://textile/./src/textile/re_ext.js","webpack://textile/./src/merge.js","webpack://textile/./src/jsonml.js","webpack://textile/./src/textile/flow.js","webpack://textile/./src/builder.js","webpack://textile/./src/index.js","webpack://textile/./src/fixlinks.js","webpack://textile/./src/mergeConcatClassname.js","webpack://textile/./src/textile/glyph.js","webpack://textile/./src/textile/list.js","webpack://textile/./src/textile/deflist.js","webpack://textile/./src/textile/table.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_cache","re","pattern","escape","src","replace","collapse","expandPatterns","k","ex","Error","isRegExp","toString","compile","flags","arguments","length","global","ignoreCase","multiline","source","ckey","rx","test","RegExp","feed","slot","org","String","pos","self","index","save","getSlot","getPos","load","slice","advance","skipWS","ws","exec","lookbehind","nchars","startsWith","substring","a","b","valueOf","reClassid","rePaddingL","rePaddingR","reAlignBlock","reAlignImg","reVAlign","reColSpan","reRowSpan","reStyles","reCSS","reLang","pbaAlignLookup","pbaVAlignLookup","copyAttr","blacklist","parseAttr","input","element","endToken","st","remaining","isBlock","isImg","isList","isPhrase","reAlign","split","forEach","match","rm","bits","class","id","align","v","push","style","join","undefined","addLineNumber","jsonmlEntryAttr","options","charPosToLine","charOffset","charPos","charPosEnd","showOriginalLineNumber","cssClassOriginalLineNumber","require","ribbon","html_id","html_attr","reAttr","reComment","reEndTag","reTag","reHtmlTagBlock","singletons","area","base","br","col","embed","hr","img","link","meta","option","param","wbr","allowAll","testComment","testOpenTag","testCloseTag","parseHtmlAttr","attrSrc","attr","tokenize","whitelistTags","lazy","tokens","textMode","oktag","tag","oktag_","nesting","nestCount","type","data","token","isNaN","parseHtml","stack","curr","elm","splice","sourceLength","testOpenTagBlock","builder","mergeConcatClassname","parseGlyph","ucaps","txattr","txcite","phraseConvert","rePhrase","reImage","reImageFenced","reCaps","reLink","reLinkFenced","reLinkTitle","reFootnote","parsePhrase","pba","list","breaks","add","srcSlot","behind","boundary","tok","fence","phraseType","code","mMid","mEnd","t1","charAt","srcPos","concat","alt","title","single","pbaLineNumber","merge","href","caps","inner","map","txblocks","attr_class","attr_style","attr_lang","attr_align","attr_pad","txlisthd","txlisthd2","text","escapeQuotes","hasAttributes","ml","Array","isArray","isNode","mlPart","reIndent","shiftBy","toHTML","jsonml","renderers","context","shouldEscape","dontEscapeContentForTags","shift","attributes","tagAttrs","content","includes","realContent","render","indexOf","applyHooks","hooks","level","realLevel","hook","addAttributes","newAttr","assign","fixLink","testList","parseList","testDefList","parseDefList","testTable","parseTable","allowedBlocktags","reBlock","reBlockNormal","reBlockExtended","reBlockNormalPre","reBlockExtendedPre","reRuler","reLinkRef","reFootnoteDef","reCleanBegin","hasOwn","extend","target","nextKey","paragraph","linebreak","out","bit","localCharOffset","removedSrc","trim","parseFlow","lineOffset","linkRefs","charLineOffset","computeCharOffset","realSrc","storeCharPosToLine","blockType","extended","reBlockGlob","cite","par","subPba","fnid","x","pop","innerHTML","innerElm","initArr","arr","node","filter","jsonmlUtils","textile","txt","opt","defaults","setOptions","setoptions","parse","convert","html_parser","serialize","dict","reApostrophe","reArrow","reClosingDQuote","reClosingSQuote","reCopyright","reDimsign","reDoublePrime","reEllipsis","reEmdash","reEndash","reOpenDQuote","reOpenSQuote","reRegistered","reSinglePrime","reTrademark","reList","reItem","listPad","listAttr","currIndex","lastIndex","_lst","itemIndex","item","destLevel","substr","newLi","lst","isFinite","parseInt","li","ul","att","start","apply","reDeflist","terms","def","deflist","separators","term","reTable","reHead","reRowCapture","reCaption","reColgroup","reRowgroup","charToTag","parseColgroup","colgroup","isCol","span","width","caption","tCurr","row","more","rowgroups","tAttr","setRowGroup","summary","th","cell","mx","table","tbody"],"mappings":"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","file":"textile.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","/*\n** Regular Expression helper methods\n**\n** This provides the `re` object, which contains several helper\n** methods for working with big regular expressions (soup).\n**\n*/\n\nconst _cache = {};\n\nconst re = module.exports = {\n\n  pattern: {\n    'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n    'space': '\\\\s'\n  },\n\n  escape: function ( src ) {\n    return src.replace( /[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&' );\n  },\n\n  collapse: function ( src ) {\n    return src.replace( /(?:#.*?(?:\\n|$))/g, '' )\n      .replace( /\\s+/g, '' );\n  },\n\n  expandPatterns: function ( src ) {\n    // TODO: provide escape for patterns: \\[:pattern:] ?\n    return src.replace( /\\[:\\s*(\\w+)\\s*:\\]/g, function ( m, k ) {\n      const ex = re.pattern[k];\n      if ( ex ) {\n        return re.expandPatterns( ex );\n      }\n      else {\n        throw new Error( 'Pattern ' + m + ' not found in ' + src );\n      }\n    });\n  },\n\n  isRegExp: function ( r ) {\n    return Object.prototype.toString.call( r ) === '[object RegExp]';\n  },\n\n  compile: function ( src, flags ) {\n    if ( re.isRegExp( src ) ) {\n      if ( arguments.length === 1 ) { // no flags arg provided, use the RegExp one\n        flags = ( src.global ? 'g' : '' ) +\n                ( src.ignoreCase ? 'i' : '' ) +\n                ( src.multiline ? 'm' : '' );\n      }\n      src = src.source;\n    }\n    // don't do the same thing twice\n    const ckey = src + ( flags || '' );\n    if ( ckey in _cache ) {\n      return _cache[ ckey ];\n    }\n    // allow classes\n    let rx = re.expandPatterns( src );\n    // allow verbose expressions\n    if ( flags && /x/.test( flags ) ) {\n      rx = re.collapse( rx );\n    }\n    // allow dotall expressions\n    if ( flags && /s/.test( flags ) ) {\n      rx = rx.replace( /([^\\\\])\\./g, '$1[^\\\\0]' );\n    }\n    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n    // clean flags and output new regexp\n    flags = ( flags || '' ).replace( /[^gim]/g, '' );\n    return ( _cache[ ckey ] = new RegExp( rx, flags ) );\n  }\n\n};\n","module.exports = function ribbon ( feed ) {\n  const org = String( feed );\n  let slot;\n  let pos = 0;\n  const self = {\n\n    index: () => {\n      return pos;\n    },\n\n    save: () => {\n      slot = pos;\n      return self;\n    },\n\n    getSlot: () => {\n      return slot || 0;\n    },\n\n    getPos: () => {\n      return pos || 0;\n    },\n\n    load: () => {\n      pos = slot;\n      feed = org.slice( pos );\n      return self;\n    },\n\n    advance: n => {\n      pos += ( typeof n === 'string' ) ? n.length : n;\n      feed = org.slice( pos );\n      return feed;\n    },\n\n    skipWS: () => {\n      const ws = /^\\s+/.exec( feed );\n      if ( ws ) {\n        pos += ws[0].length;\n        feed = org.slice( pos );\n        return ws[0];\n      }\n      return '';\n    },\n\n    lookbehind: nchars => {\n      nchars = nchars == null ? 1 : nchars;\n      return org.slice( pos - nchars, pos );\n    },\n\n    startsWith: s => {\n      return feed.substring( 0, s.length ) === s;\n    },\n\n    slice: ( a, b ) => {\n      return b != null ? feed.slice( a, b ) : feed.slice( a );\n    },\n\n    valueOf: () => {\n      return feed;\n    },\n\n    toString: () => {\n      return feed;\n    }\n\n  };\n\n  return self;\n};\n","const reClassid = /^\\(([^()\\n]+)\\)/;\nconst rePaddingL = /^(\\(+)/;\nconst rePaddingR = /^(\\)+)/;\nconst reAlignBlock = /^(<>|<|>|=)/;\nconst reAlignImg = /^(<|>|=)/;\nconst reVAlign = /^(~|\\^|-)/;\nconst reColSpan = /^\\\\(\\d+)/;\nconst reRowSpan = /^\\/(\\d+)/;\nconst reStyles = /^\\{([^}]*)\\}/;\nconst reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\nconst reLang = /^\\[([^[\\]\\n]+)\\]/;\n\nconst pbaAlignLookup = {\n  '<': 'left',\n  '=': 'center',\n  '>': 'right',\n  '<>': 'justify'\n};\n\nconst pbaVAlignLookup = {\n  '~': 'bottom',\n  '^': 'top',\n  '-': 'middle'\n};\n\nfunction copyAttr ( s, blacklist ) {\n  if ( !s ) { return undefined; }\n  const d = {};\n  for ( const k in s ) {\n    if ( k in s && ( !blacklist || !( k in blacklist ) ) ) {\n      d[ k ] = s[ k ];\n    }\n  }\n  return d;\n}\n\nfunction testBlock ( name ) {\n  // \"in\" test would be better but what about fn#.?\n  return /^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test( name );\n}\n\n/*\n  The attr bit causes massive problems for span elements when parentheses are used.\n  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\n   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\n  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n  if it is followed by `endToken` or <space>.\n\n  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n  out there in the real world. So this attempts to emulate the other libraries.\n*/\nfunction parseAttr ( input, element, endToken ) {\n  input = String( input );\n  if ( !input || element === 'notextile' ) {\n    return undefined;\n  }\n\n  let m;\n  const st = {};\n  const o = { 'style': st };\n  let remaining = input;\n\n  const isBlock = testBlock( element );\n  const isImg = element === 'img';\n  const isList = element === 'li';\n  const isPhrase = !isBlock && !isImg && element !== 'a';\n  const reAlign = ( isImg ) ? reAlignImg : reAlignBlock;\n\n  do {\n    if ( ( m = reStyles.exec( remaining ) ) ) {\n      m[1].split( ';' ).forEach( function ( p ) {\n        const d = p.match( reCSS );\n        if ( d ) { st[ d[1] ] = d[2]; }\n      });\n      remaining = remaining.slice( m[0].length );\n      continue;\n    }\n\n    if ( ( m = reLang.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if ( ( !rm && isPhrase ) ||\n           ( endToken && endToken === rm.slice( 0, endToken.length ) ) ) {\n        m = null;\n      }\n      else {\n        o['lang'] = m[1];\n        remaining = remaining.slice( m[0].length );\n      }\n      continue;\n    }\n\n    if ( ( m = reClassid.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if (\n        ( !rm && isPhrase ) ||\n          ( endToken && ( rm[0] === ' ' || endToken === rm.slice( 0, endToken.length ) ) )\n      ) {\n        m = null;\n      }\n      else {\n        const bits = m[1].split( '#' );\n        if ( bits[0] ) { o.class = bits[0]; }\n        if ( bits[1] ) { o.id = bits[1]; }\n        remaining = rm;\n      }\n      continue;\n    }\n\n    if ( isBlock || isList ) {\n      if ( ( m = rePaddingL.exec( remaining ) ) ) {\n        st[ 'padding-left' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = rePaddingR.exec( remaining ) ) ) {\n        st[ 'padding-right' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for blocks:\n    if ( isImg || isBlock || isList ) {\n      if ( ( m = reAlign.exec( remaining ) ) ) {\n        const align = pbaAlignLookup[ m[1] ];\n        if ( isImg ) {\n          o[ 'align' ] = align;\n        }\n        else {\n          st[ 'text-align' ] = align;\n        }\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for table cells\n    if ( element === 'td' || element === 'tr' ) {\n      if ( ( m = reVAlign.exec( remaining ) ) ) {\n        st[ 'vertical-align' ] = pbaVAlignLookup[ m[1] ];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n    if ( element === 'td' ) {\n      if ( ( m = reColSpan.exec( remaining ) ) ) {\n        o[ 'colspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = reRowSpan.exec( remaining ) ) ) {\n        o[ 'rowspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n  }\n  while ( m );\n\n  // collapse styles\n  const s = [];\n  for ( const v in st ) {\n    s.push( `${ v }:${ st[v] }` );\n  }\n  if ( s.length ) {\n    o.style = s.join( ';' );\n  }\n  else {\n    delete o.style;\n  }\n\n  return ( remaining === input ) ? undefined : [ input.length - remaining.length, o ];\n}\n\nfunction addLineNumber ( jsonmlEntryAttr, options, charPosToLine, charOffset, charPos, charPosEnd ) {\n  if ( options.showOriginalLineNumber && charPosToLine ) {\n    charOffset = charOffset || 0;\n    if ( !jsonmlEntryAttr ) {\n      jsonmlEntryAttr = {};\n    }\n    jsonmlEntryAttr['data-line'] = charPosToLine[ charOffset + charPos ];\n    if ( typeof charPosEnd !== 'undefined' ) {\n      jsonmlEntryAttr['data-line-end'] = charPosToLine[ charOffset + charPosEnd ];\n    }\n    if ( options.cssClassOriginalLineNumber ) {\n      jsonmlEntryAttr['class'] = ( jsonmlEntryAttr['class'] ? jsonmlEntryAttr['class'] + ' ' : '' ) + options.cssClassOriginalLineNumber;\n    }\n  }\n  return jsonmlEntryAttr;\n}\n\nmodule.exports = {\n  copyAttr: copyAttr,\n  parseAttr: parseAttr,\n  addLineNumber: addLineNumber\n};\n","const re = require( './re' );\nconst ribbon = require( './ribbon' );\n\nre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\nre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\nconst reAttr = re.compile( /^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/ );\nconst reComment = re.compile( /^<!--(.+?)-->/, 's' );\nconst reEndTag = re.compile( /^<\\/([:html_id:])([^>]*)>/ );\nconst reTag = re.compile( /^<([:html_id:])((?:\\s[^=\\s/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/ );\nconst reHtmlTagBlock = re.compile( /^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/ );\n\nconst singletons = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  link: 1,\n  meta: 1,\n  option: 1,\n  param: 1,\n  wbr: 1\n};\n\nfunction allowAll () {\n  return true;\n}\n\nfunction testComment ( src ) {\n  return reComment.exec( src );\n}\n\nfunction testOpenTagBlock ( src ) {\n  return reHtmlTagBlock.exec( src );\n}\n\nfunction testOpenTag ( src ) {\n  return reTag.exec( src );\n}\n\nfunction testCloseTag ( src ) {\n  return reEndTag.exec( src );\n}\n\nfunction parseHtmlAttr ( attrSrc ) {\n  // parse ATTR and add to element\n  const attr = {};\n  let m;\n  while ( ( m = reAttr.exec( attrSrc ) ) ) {\n    attr[ m[1] ] = ( typeof m[2] === 'string' ) ? m[2].replace( /^([\"'])(.*)\\1$/, '$2' ) : null;\n    attrSrc = attrSrc.slice( m[0].length );\n  }\n  return attr;\n}\n\nconst OPEN = 'OPEN';\nconst CLOSE = 'CLOSE';\nconst SINGLE = 'SINGLE';\nconst TEXT = 'TEXT';\nconst COMMENT = 'COMMENT';\nconst WS = 'WS';\n\nfunction tokenize ( src, whitelistTags, lazy ) {\n  const tokens = [];\n  let textMode = false;\n  let oktag = whitelistTags ? ( tag ) => tag in whitelistTags : allowAll;\n  const oktag_ = oktag;\n  const nesting = {};\n  let nestCount = 0;\n  let m;\n\n  src = ribbon( String( src ) );\n\n  do {\n    // comment\n    if ( ( m = testComment( src ) ) && oktag( '!' ) ) {\n      tokens.push({\n        type: COMMENT,\n        data: m[1],\n        pos: src.index(),\n        src: m[0]\n      });\n      src.advance( m[0] );\n    }\n\n    // end tag\n    else if ( ( m = testCloseTag( src ) ) && oktag( m[1] ) ) {\n      const token = {\n        type: CLOSE,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      src.advance( m[0] );\n      tokens.push( token );\n      nesting[token.tag]--;\n      nestCount--;\n      // console.log( '/' + token.tag, nestCount, nesting );\n      if ( lazy && (\n        !nestCount ||\n        !nesting[token.tag] < 0 ||\n        isNaN( nesting[token.tag] )\n      ) ) {\n        return tokens;\n      }\n      // if parse is in text mode then that ends here\n      if ( textMode ) {\n        textMode = null;\n        oktag = oktag_;\n      }\n    }\n\n    // open/void tag\n    else if ( ( m = testOpenTag( src ) ) && oktag( m[1] ) ) {\n      const token = {\n        type: m[3] || m[1] in singletons ? SINGLE : OPEN,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      if ( m[2] ) {\n        token.attr = parseHtmlAttr( m[2] );\n      }\n      // some elements can move parser into \"text\" mode\n      if ( m[1] === 'script' || m[1] === 'code' || m[1] === 'style' ) {\n        textMode = token.tag;\n        oktag = tag => tag === textMode;\n      }\n      if ( token.type === OPEN ) {\n        nestCount++;\n        nesting[token.tag] = ( nesting[token.tag] || 0 ) + 1;\n        // console.log( token.tag, nestCount, nesting );\n      }\n      tokens.push( token );\n      src.advance( m[0] );\n    }\n\n    // text content\n    else {\n      // no match, move by all \"uninteresting\" chars\n      m = /([^<]+|[^\\0])/.exec( src );\n      if ( m ) {\n        tokens.push({\n          type: TEXT,\n          data: m[0],\n          pos: src.index(),\n          src: m[0]\n        });\n      }\n      src.advance( m ? m[0].length || 1 : 1 );\n    }\n  }\n  while ( src.valueOf() );\n\n  return tokens;\n}\n\n// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\nfunction parse ( tokens, lazy ) {\n  const root = [];\n  const stack = [];\n  let curr = root;\n  let token;\n  for ( let i = 0; i < tokens.length; i++ ) {\n    token = tokens[i];\n    if ( token.type === COMMENT ) {\n      curr.push( [ '!', token.data ] );\n    }\n    else if ( token.type === TEXT || token.type === WS ) {\n      curr.push( token.data );\n    }\n    else if ( token.type === SINGLE ) {\n      curr.push( token.attr ? [ token.tag, token.attr ] : [ token.tag ] );\n    }\n    else if ( token.type === OPEN ) {\n      // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n      // https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission\n      const elm = token.attr ? [ token.tag, token.attr ] : [ token.tag ];\n      curr.push( elm );\n      stack.push( elm );\n      curr = elm;\n    }\n    else if ( token.type === CLOSE ) {\n      if ( stack.length ) {\n        for ( let i = stack.length - 1; i >= 0; i-- ) {\n          const head = stack[i];\n          if ( head[0] === token.tag ) {\n            stack.splice( i );\n            curr = stack[stack.length - 1] || root;\n            break;\n          }\n        }\n      }\n      if ( !stack.length && lazy ) {\n        root.sourceLength = token.pos + token.src.length;\n        return root;\n      }\n    }\n  }\n  root.sourceLength = token ? token.pos + token.src.length : 0;\n  return root;\n}\n\nmodule.exports = {\n  singletons: singletons,\n  tokenize: tokenize,\n  parseHtml: parse,\n  parseHtmlAttr: parseHtmlAttr,\n  testCloseTag: testCloseTag,\n  testOpenTagBlock: testOpenTagBlock,\n  testOpenTag: testOpenTag,\n  testComment: testComment\n};\n","/* textile inline parser */\n\nconst ribbon = require( '../ribbon' );\nconst builder = require( '../builder' );\nconst re = require( '../re' );\nconst mergeConcatClassname = require( '../mergeConcatClassname' );\n\nconst { parseAttr, addLineNumber } = require( './attr' );\nconst { parseGlyph } = require( './glyph' );\nconst { parseHtml, parseHtmlAttr, tokenize, singletons, testComment, testOpenTag } = require( '../html' );\n\nconst { ucaps, txattr, txcite } = require( './re_ext' );\nre.pattern.txattr = txattr;\nre.pattern.txcite = txcite;\nre.pattern.ucaps = ucaps;\n\nconst phraseConvert = {\n  '*': 'strong',\n  '**': 'b',\n  '??': 'cite',\n  '_': 'em',\n  '__': 'i',\n  '-': 'del',\n  '%': 'span',\n  '+': 'ins',\n  '~': 'sub',\n  '^': 'sup',\n  '@': 'code'\n};\n\nconst rePhrase = /^([[{]?)(__?|\\*\\*?|\\?\\?|[-+^~@%])/;\nconst reImage = re.compile( /^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^./]))?)([^!\\s]+?) ?(?:\\(((?:[^()]|\\([^()]+\\))+)\\))?!(?::([^\\s]+?(?=[!-.:-@[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/ );\nconst reImageFenced = re.compile( /^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^./]))?)([^!\\s]+?) ?(?:\\(((?:[^()]|\\([^()]+\\))+)\\))?!(?::([^\\s]+?(?=[!-.:-@[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/ );\n// NB: there is an exception in here to prevent matching \"TM)\"\nconst reCaps = re.compile( /^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/ );\nconst reLink = re.compile( /^\"(?!\\s)((?:[^\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/ );\nconst reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\nconst reLinkTitle = /\\s*\\(((?:\\([^()]*\\)|[^()])+)\\)$/;\nconst reFootnote = /^\\[(\\d+)(!?)\\]/;\n\nfunction parsePhrase ( src, options, charPosToLine, charOffset ) {\n  src = ribbon( src );\n  const list = builder();\n  let m;\n  let pba;\n\n  // loop\n  do {\n    src.save();\n\n    // linebreak -- having this first keeps it from messing to much with other phrases\n    if ( src.startsWith( '\\r\\n' ) ) {\n      src.advance( 1 ); // skip cartridge returns\n    }\n    if ( src.startsWith( '\\n' ) ) {\n      src.advance( 1 );\n      if ( src.startsWith( ' ' ) ) {\n        src.advance( 1 );\n      }\n      else if ( options.breaks ) {\n        list.add( [ 'br' ] );\n      }\n      list.add( '\\n' );\n      continue;\n    }\n\n    // inline notextile\n    if ( ( m = /^==(.*?)==/.exec( src ) ) ) {\n      src.advance( m[0] );\n      list.add( m[1] );\n      continue;\n    }\n\n    const srcSlot = src.getPos();\n\n    // lookbehind => /([\\s>.,\"'?!;:])$/\n    const behind = src.lookbehind( 1 );\n    const boundary = !behind || /^[\\s<>.,\"'?!;:()[\\]%{}]$/.test( behind );\n    // FIXME: need to test right boundary for phrases as well\n    if ( ( m = rePhrase.exec( src ) ) && ( boundary || m[1] ) ) {\n      src.advance( m[0] );\n      const tok = m[2];\n      const fence = m[1];\n      const phraseType = phraseConvert[tok];\n      const code = phraseType === 'code';\n\n      if ( ( pba = !code && parseAttr( src, phraseType, tok ) ) ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n      // seek end\n      let mMid;\n      let mEnd;\n      if ( fence === '[' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:])';\n      }\n      else if ( fence === '{' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:})';\n      }\n      else {\n        const t1 = re.escape( tok.charAt( 0 ) );\n        mMid = ( code ) ? '^(\\\\S+|\\\\S+.*?\\\\S)'\n          : `^([^\\\\s${ t1 }]+|[^\\\\s${ t1 }].*?\\\\S(${ t1 }*))`;\n        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’<>])';\n      }\n      const rx = re.compile( `${ mMid }(${ re.escape( tok ) })${ mEnd }` );\n      // no line number here: they are not block level elements\n      if ( ( m = rx.exec( src ) ) && m[1] ) {\n        const srcPos = src.getPos();\n        src.advance( m[0] );\n        if ( code ) {\n          list.add( [ phraseType, m[1] ] );\n        }\n        else {\n          list.add( [ phraseType, pba ].concat( parsePhrase( m[1], options, charPosToLine, charOffset + srcPos ) ) );\n        }\n        continue;\n      }\n      // else\n      src.load();\n    }\n\n    // image\n    if ( ( m = reImage.exec( src ) ) || ( m = reImageFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n\n      pba = m[1] && parseAttr( m[1], 'img' );\n      const attr = pba ? pba[1] : { 'src': '' };\n      let img = [ 'img', mergeConcatClassname( attr, options.showOriginalLineNumber ? addLineNumber({}, options, charPosToLine, charOffset, srcSlot ) : undefined ) ];\n      attr.src = m[2];\n      attr.alt = m[3] ? ( attr.title = m[3] ) : '';\n\n      if ( m[4] ) { // +cite causes image to be wraped with a link (or link_ref)?\n        // TODO: support link_ref for image cite\n        img = [ 'a', { 'href': m[4] }, img ];\n      }\n      list.add( img );\n      continue;\n    }\n\n    // html comment\n    if ( ( m = testComment( src ) ) ) {\n      const elm = [ '!' ];\n      if ( options.showOriginalLineNumber ) {\n        elm.push( addLineNumber({}, options, charPosToLine, charOffset, src.getSlot() ) );\n      }\n      elm.push( m[1] );\n      list.add( elm );\n      src.advance( m[0] );\n      continue;\n    }\n    // html tag\n    // TODO: this seems to have a lot of overlap with block tags... DRY?\n    if ( ( m = testOpenTag( src ) ) ) {\n      src.advance( m[0] );\n      const srcPos = src.getPos();\n      const tag = m[1];\n      const single = m[3] || m[1] in singletons;\n      let element = [ tag ];\n      const attr = m[2] ? parseHtmlAttr( m[2] ) : undefined;\n\n      if ( single ) { // single tag\n        const pbaLineNumber = options.showOriginalLineNumber ? addLineNumber({}, options, charPosToLine, charOffset, srcSlot ) : undefined;\n        if ( attr ) {\n          element.push( mergeConcatClassname( attr, pbaLineNumber ) );\n        }\n        else if ( pbaLineNumber ) {\n          element.push( pbaLineNumber );\n        }\n        list.add( element ).add( src.skipWS() );\n        continue;\n      }\n      else { // need terminator\n        // gulp up the rest of this block...\n        const reEndTag = re.compile( `^(.*?)(</${ tag }\\\\s*>)`, 's' );\n        if ( ( m = reEndTag.exec( src ) ) ) {\n          const pbaLineNumber = options.showOriginalLineNumber ? addLineNumber({}, options, charPosToLine, charOffset, srcSlot, srcSlot + ( m[0].length > 0 ? m[0].length - 1 : 0 ) ) : undefined;\n          if ( attr ) {\n            element.push( mergeConcatClassname( attr, pbaLineNumber ) );\n          }\n          else if ( pbaLineNumber ) {\n            element.push( pbaLineNumber );\n          }\n\n          src.advance( m[0] );\n          if ( tag === 'code' ) {\n            element.push( m[1] );\n          }\n          else if ( tag === 'notextile' ) {\n            // HTML is still parsed, even though textile is not\n            list.merge( parseHtml( tokenize( m[1] ) ) );\n            continue;\n          }\n          else {\n            element = element.concat( parsePhrase( m[1], options, charPosToLine, charOffset + srcPos ) );\n          }\n          list.add( element );\n          continue;\n        }\n        // end tag is missing, treat tag as normal text...\n      }\n      src.load();\n    }\n\n    // footnote\n    if ( ( m = reFootnote.exec( src ) ) && /\\S/.test( behind ) ) {\n      src.advance( m[0] );\n      list.add( [ 'sup', { 'class': 'footnote', 'id': 'fnr' + m[1] },\n        ( m[2] === '!' ? m[1] // \"!\" suppresses the link\n          : [ 'a', { href: '#fn' + m[1] }, m[1] ] )\n      ] );\n      continue;\n    }\n\n    // caps / abbr\n    if ( ( m = reCaps.exec( src ) ) ) {\n      src.advance( m[0] );\n      let caps = [ 'span', { 'class': 'caps' }, m[1] ];\n      if ( m[2] ) {\n        // FIXME: use <abbr>, not acronym!\n        caps = [ 'acronym', { 'title': m[2] }, caps ];\n      }\n      list.add( caps );\n      continue;\n    }\n\n    // links\n    if ( ( boundary && ( m = reLink.exec( src ) ) ) ||\n                       ( m = reLinkFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n      let title = m[1].match( reLinkTitle );\n      let inner = ( title ) ? m[1].slice( 0, m[1].length - title[0].length ) : m[1];\n      if ( ( pba = parseAttr( inner, 'a' ) ) ) {\n        inner = inner.slice( pba[0] );\n        pba = pba[1];\n      }\n      else {\n        pba = {};\n      }\n      if ( title && !inner ) {\n        inner = title[0];\n        title = '';\n      }\n      pba.href = m[2];\n      if ( title ) { pba.title = title[1]; }\n      // links may self-reference their url via $\n      if ( inner === '$' ) {\n        inner = pba.href.replace( /^(https?:\\/\\/|ftps?:\\/\\/|mailto:)/, '' );\n      }\n      // FIXME : small shift, because parsePhrase is called with an inexact offset\n      list.add( [ 'a', pba ].concat( parsePhrase( inner.replace( /^(\\.?\\s*)/, '' ), options, charPosToLine, charOffset + src.getSlot() ) ) );\n      continue;\n    }\n\n    // no match, move by all \"uninteresting\" chars\n    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec( src );\n    if ( m ) {\n      list.add( m[0] );\n    }\n    src.advance( m ? m[0].length || 1 : 1 );\n  }\n  while ( src.valueOf() );\n\n  return list.get().map( parseGlyph );\n}\n\nexports.parsePhrase = parsePhrase;\n","/* eslint camelcase: 0 */\n\nexports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\nexports.ucaps = 'A-Z' +\n    // Latin extended À-Þ\n    '\\u00c0-\\u00d6\\u00d8-\\u00de' +\n    // Latin caps with embelishments and ligatures...\n    '\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f' +\n    '\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d' +\n    '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc' +\n    '\\u01c4\\u01c7\\u01ca\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe' +\n    '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e' +\n    '\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e' +\n    '\\u1e00\\u1e02\\u1e04\\u1e06\\u1e08\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1e1e\\u1e20\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u1e2c\\u1e2e\\u1e30\\u1e32\\u1e34\\u1e36\\u1e38\\u1e3a\\u1e3c\\u1e3e\\u1e40' +\n    '\\u1e42\\u1e44\\u1e46\\u1e48\\u1e4a\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1e54\\u1e56\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1e7c\\u1e7e' +\n    '\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u1e8a\\u1e8c\\u1e8e\\u1e90\\u1e92\\u1e94\\u1e9e\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u1eb8\\u1eba\\u1ebc\\u1ebe' +\n    '\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u1ec8\\u1eca\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efa\\u1efc\\u1efe' +\n    '\\u2c60\\u2c62-\\u2c64\\u2c67\\u2c69\\u2c6b\\u2c6d-\\u2c70\\u2c72\\u2c75\\u2c7e\\u2c7f' +\n    '\\ua722\\ua724\\ua726\\ua728\\ua72a\\ua72c\\ua72e\\ua732\\ua734\\ua736\\ua738\\ua73a\\ua73c\\ua73e' +\n    '\\ua740\\ua742\\ua744\\ua746\\ua748\\ua74a\\ua74c\\ua74e\\ua750\\ua752\\ua754\\ua756\\ua758\\ua75a\\ua75c\\ua75e\\ua760\\ua762\\ua764\\ua766\\ua768\\ua76a\\ua76c\\ua76e\\ua779\\ua77b\\ua77d\\ua77e' +\n    '\\ua780\\ua782\\ua784\\ua786\\ua78b\\ua78d\\ua790\\ua792\\ua7a0\\ua7a2\\ua7a4\\ua7a6\\ua7a8\\ua7aa';\n\nexports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\nconst attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\nconst attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\nconst attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\nconst attr_align = exports.attr_align = '(?:<>|<|>|=)';\nconst attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\nconst txattr = exports.txattr = `(?:${ attr_class }|${ attr_style }|${ attr_lang }|${ attr_align }|${ attr_pad })*`;\n\nexports.txlisthd = `[\\\\t ]*(\\\\*|\\\\#(?:_|\\\\d+)?)${ txattr }(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\nexports.txlisthd2 = `[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)${ txattr }(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\n","// merge object b properties into object a\nmodule.exports = function merge ( a, b ) {\n  if ( b ) {\n    for ( const k in b ) {\n      a[ k ] = b[ k ];\n    }\n  }\n  return a;\n};\n","/*\n** JSONML helper methods - http://www.jsonml.org/\n**\n** This provides the `JSONML` object, which contains helper\n** methods for rendering JSONML to HTML.\n**\n** Note that the tag ! is taken to mean comment, this is however\n** not specified in the JSONML spec.\n*/\n\nconst singletons = require( './html' ).singletons;\n\n// drop or add tab levels to JsonML tree\nfunction reIndent ( ml, shiftBy ) {\n  // a bit obsessive, but there we are...\n  if ( !shiftBy ) {\n    return ml;\n  }\n  return ml.map( function ( s ) {\n    if ( /^\\n\\t+/.test( s ) ) {\n      if ( shiftBy < 0 ) {\n        s = s.slice( 0, shiftBy );\n      }\n      else {\n        for ( let i = 0; i < shiftBy; i++ ) {\n          s += '\\t';\n        }\n      }\n    }\n    else if ( Array.isArray( s ) ) {\n      return reIndent( s, shiftBy );\n    }\n    return s;\n  });\n}\n\nfunction escape ( text, escapeQuotes ) {\n  return text.replace( /&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;' )\n    .replace( /</g, '&lt;' )\n    .replace( />/g, '&gt;' )\n    .replace( /\"/g, escapeQuotes ? '&quot;' : '\"' )\n    .replace( /'/g, escapeQuotes ? '&#39;' : \"'\" );\n}\n\nfunction toHTML ( jsonml, renderers, options = {}, context = undefined ) {\n  const shouldEscape = options.shouldEscape === undefined ? true : options.shouldEscape;\n  const dontEscapeContentForTags = options.dontEscapeContentForTags || [];\n\n  jsonml = jsonml.concat();\n\n  // basic case\n  if ( typeof jsonml === 'string' ) {\n    return shouldEscape ? escape( jsonml ) : jsonml;\n  }\n\n  const tag = jsonml.shift();\n  let attributes = {};\n  let tagAttrs = '';\n  const content = [];\n\n  if ( jsonml.length && typeof jsonml[0] === 'object' && !Array.isArray( jsonml[0] ) ) {\n    attributes = jsonml.shift();\n  }\n\n  while ( jsonml.length ) {\n    content.push( toHTML( jsonml.shift(), renderers, {\n      dontEscapeContentForTags,\n      shouldEscape: shouldEscape && !dontEscapeContentForTags.includes( tag )\n    }) );\n  }\n\n  let realContent = content.join( '' );\n  if ( Array.isArray( renderers ) ) {\n    renderers.forEach( render => {\n      realContent = render( tag, attributes, realContent, context );\n    });\n  }\n\n  for ( const a in attributes ) {\n    tagAttrs += ( attributes[a] == null )\n      ? ` ${ a }`\n      : ` ${ a }=\"${ escape( String( attributes[a] ), true ) }\"`;\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if ( tag === '!' ) {\n    return `<!--${ realContent }-->`;\n  }\n  else if ( tag in singletons || ( tag.indexOf( ':' ) > -1 && !realContent.length ) ) {\n    return `<${ tag }${ tagAttrs } />`;\n  }\n  else {\n    return `<${ tag }${ tagAttrs }>${ realContent }</${ tag }>`;\n  }\n}\n\nfunction applyHooks ( ml, hooks = [], level = undefined, context = undefined ) {\n  if ( Array.isArray( ml ) && Array.isArray( hooks ) && hooks.length ) {\n    let realLevel = +level || 0;\n    for ( let i = 0, l = hooks.length; i < l; i++ ) {\n      const hook = hooks[i];\n      hook[0]( ml, hook[1], realLevel, context );\n    }\n    realLevel++;\n    for ( let i = 0, l = ml.length; i < l; i++ ) {\n      if ( Array.isArray( ml[i] ) ) {\n        applyHooks( ml[i], hooks, realLevel, context );\n      }\n    }\n  }\n  return ml;\n}\n\nfunction isNode ( ml ) {\n  return Array.isArray( ml ) && typeof ml[0] === 'string';\n};\n\nfunction isAttributes ( mlPart ) {\n  return typeof mlPart === 'object' && !Array.isArray( mlPart );\n};\n\nfunction hasAttributes ( ml ) {\n  if ( !isNode( ml ) ) {\n    throw new Error( 'Not a jsonML node' );\n  }\n\n  return isAttributes( ml[1] );\n};\n\nfunction addAttributes ( ml, newAttr ) {\n  if ( hasAttributes( ml ) ) {\n    return Object.assign( ml[1], newAttr );\n  }\n  else {\n    const attr = Object.assign({}, newAttr );\n    ml.splice( 1, 0, attr );\n\n    return attr;\n  }\n};\n\nmodule.exports = {\n  reIndent: reIndent,\n  toHTML: toHTML,\n  escape: escape,\n  applyHooks: applyHooks,\n  addAttributes: addAttributes\n};\n","/*\n** textile flow content parser\n*/\nconst builder = require( '../builder' );\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst fixLink = require( '../fixlinks' );\nconst jsonml = require( '../jsonml' );\n\nconst { parseHtml, tokenize, parseHtmlAttr, singletons, testComment, testOpenTagBlock } = require( '../html' );\n\nconst { parsePhrase } = require( './phrase' );\nconst { copyAttr, parseAttr, addLineNumber } = require( './attr' );\nconst { testList, parseList } = require( './list' );\nconst { testDefList, parseDefList } = require( './deflist' );\nconst { testTable, parseTable } = require( './table' );\n\nconst { txblocks, txlisthd, txattr } = require( './re_ext' );\nre.pattern.txblocks = txblocks;\nre.pattern.txlisthd = txlisthd;\nre.pattern.txattr = txattr;\n\n// HTML tags allowed in the document (root) level that trigger HTML parsing\nconst allowedBlocktags = {\n  'p': 0,\n  'hr': 0,\n  'ul': 1,\n  'ol': 0,\n  'li': 0,\n  'div': 1,\n  'pre': 0,\n  'object': 1,\n  'script': 0,\n  'noscript': 0,\n  'blockquote': 1,\n  'notextile': 1\n};\n\nconst reBlock = re.compile( /^([:txblocks:])/ );\nconst reBlockNormal = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's' );\nconst reBlockExtended = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's' );\nconst reBlockNormalPre = re.compile( /^(.*?)($|\\r?\\n(?:\\s*\\n|$)+)/, 's' );\nconst reBlockExtendedPre = re.compile( /^(.*?)($|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's' );\n\nconst reRuler = /^(---+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\nconst reLinkRef = re.compile( /^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/ );\nconst reFootnoteDef = /^fn\\d+$/;\n\nconst reCleanBegin = /^( *\\r?\\n)+/;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\nfunction extend ( target, ...args ) {\n  for ( let i = 1; i < args.length; i++ ) {\n    const src = args[i];\n    if ( src != null ) {\n      for ( const nextKey in src ) {\n        if ( hasOwn.call( src, nextKey ) ) {\n          target[nextKey] = src[nextKey];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nfunction paragraph ( s, tag, pba, linebreak, options, charPosToLine, charOffset ) {\n  tag = tag || 'p';\n  let out = [];\n  // FIXME : this may need some work for correct offset computation\n  s.split( /(?:\\r?\\n){2,}/ ).forEach( function ( bit, i ) {\n    if ( tag === 'p' && /^\\s/.test( bit ) ) {\n      // no-paragraphs\n      let localCharOffset = 0;\n      if ( options.showOriginalLineNumber ) {\n        const removedSrc = bit.match( /^(\\r?\\n|\\t| )*/g );\n        if ( removedSrc && removedSrc[0] ) {\n          localCharOffset += removedSrc[0].length;\n        }\n      }\n      bit = bit.replace( /\\r?\\n[\\t ]/g, ' ' ).trim();\n      out = out.concat( parsePhrase( bit, options, charPosToLine, charOffset + localCharOffset ) );\n    }\n    else {\n      if ( linebreak && i ) { out.push( linebreak ); }\n      out.push( pba ? [ tag, pba ].concat( parsePhrase( bit, options, charPosToLine, charOffset ) )\n        : [ tag ].concat( parsePhrase( bit, options, charPosToLine, charOffset ) ) );\n    }\n  });\n  return out;\n};\n\nfunction computeCharOffset ( src, options, lineOffset ) {\n  if ( options.showOriginalLineNumber ) {\n    lineOffset = lineOffset || 0;\n\n    const removedSrc = src.match( reCleanBegin );\n    if ( removedSrc && removedSrc[0] ) {\n      lineOffset += ( removedSrc[0].match( /\\n/g ) || [] ).length;\n    }\n    return lineOffset;\n  }\n  else {\n    return 0;\n  }\n}\n\nfunction storeCharPosToLine ( src, options, charOffset ) {\n  // FIXME: don't store all chr ?\n  if ( options.showOriginalLineNumber ) {\n    const charPosToLine = [];\n    const realSrc = src.toString();\n    for ( const i in realSrc ) {\n      charPosToLine[ i ] = charOffset;\n      if ( realSrc[ i ] === '\\n' ) {\n        charOffset++;\n      }\n    }\n    return charPosToLine;\n  }\n  else {\n    return void 0;\n  }\n}\n\nfunction parseFlow ( src, options, lineOffset, context ) {\n  const list = builder();\n\n  let linkRefs;\n  let m;\n\n  // keep as local variable, for nested calls (->block HTML)\n  const charLineOffset = computeCharOffset( src, options, lineOffset );\n\n  src = ribbon( src.replace( reCleanBegin, '' ) );\n\n  // keep as local variable, for nested calls (->block HTML)\n  const charPosToLine = storeCharPosToLine( src, options, charLineOffset );\n\n  // loop\n  while ( src.valueOf() ) {\n    src.save();\n\n    // link_ref -- this goes first because it shouldn't trigger a linebreak\n    if ( ( m = reLinkRef.exec( src ) ) ) {\n      if ( !linkRefs ) { linkRefs = {}; }\n      src.advance( m[0] );\n      linkRefs[m[1]] = m[2];\n      continue;\n    }\n\n    // add linebreak\n    list.linebreak();\n\n    // named block\n    if ( ( m = reBlock.exec( src ) ) ) {\n      src.advance( m[0] );\n      const blockType = m[0];\n      let pba = parseAttr( src, blockType );\n\n      if ( pba ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      pba = addLineNumber( pba, options, charPosToLine, 0, src.getSlot() );\n      if ( ( m = /^\\.(\\.?)(?:\\s|(?=:))/.exec( src ) ) ) {\n        // FIXME: this whole copyAttr seems rather strange?\n        // slurp rest of block\n        const extended = !!m[1];\n        let reBlockGlob = ( extended ? reBlockExtended : reBlockNormal );\n        if ( blockType === 'bc' || blockType === 'pre' ) {\n          reBlockGlob = ( extended ? reBlockExtendedPre : reBlockNormalPre );\n        }\n        m = reBlockGlob.exec( src.advance( m[0] ) );\n        src.advance( m[0] );\n        // bq | bc | notextile | pre | h# | fn# | p | ###\n        if ( blockType === 'bq' ) {\n          let inner = m[1];\n          if ( ( m = /^:(\\S+)\\s+/.exec( inner ) ) ) {\n            if ( !pba ) { pba = {}; }\n            pba.cite = m[1];\n            inner = inner.slice( m[0].length );\n          }\n          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n          const par = paragraph( inner, 'p', copyAttr( pba, { 'cite': 1, 'id': 1 }), '\\n', options, src.getSlot() );\n          list.add( [ 'blockquote', pba, '\\n' ].concat( par ).concat( [ '\\n' ] ) );\n        }\n        else if ( blockType === 'bc' ) {\n          const subPba = ( pba ) ? copyAttr( pba, { 'id': 1 }) : null;\n          list.add( [ 'pre', pba, ( subPba ? [ 'code', subPba, m[1] ] : [ 'code', m[1] ] ) ] );\n        }\n        else if ( blockType === 'notextile' ) {\n          list.merge( parseHtml( tokenize( m[1] ) ) );\n        }\n        else if ( blockType === '###' ) {\n          // ignore the insides\n        }\n        else if ( blockType === 'pre' ) {\n          // I disagree with RedCloth, but agree with PHP here:\n          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n          // ...which seems like the whole point of having an extended pre block?\n          list.add( [ 'pre', pba, m[1] ] );\n        }\n        else if ( reFootnoteDef.test( blockType ) ) { // footnote\n          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n          const fnid = blockType.replace( /\\D+/g, '' );\n          if ( !pba ) { pba = {}; }\n          pba.class = ( pba['class'] ? pba['class'] + ' ' : '' ) + 'footnote';\n          pba.id = 'fn' + fnid;\n          list.add( [ 'p', pba, [ 'a', { 'href': '#fnr' + fnid }, [ 'sup', fnid ] ], ' ' ]\n            .concat( parsePhrase( m[1], options, charPosToLine, src.getSlot() ) ) );\n        }\n        else { // heading | paragraph\n          list.merge( paragraph( m[1], blockType, pba, '\\n', options, charPosToLine, src.getSlot() ) );\n        }\n        continue;\n      }\n      else {\n        src.load();\n      }\n    }\n\n    // HTML comment\n    if ( ( m = testComment( src ) ) ) {\n      const elm = [ '!' ];\n      if ( options.showOriginalLineNumber ) {\n        elm.push( addLineNumber({}, options, charPosToLine, 0, src.getSlot() ) );\n      }\n      elm.push( m[1] );\n      list.add( elm );\n      src.advance( m[0] + ( /(?:\\s*\\n+)+/.exec( src ) || [] )[0] );\n      continue;\n    }\n\n    // block HTML\n    if ( ( m = testOpenTagBlock( src ) ) ) {\n      const tag = m[1];\n\n      // Is block tag? ...\n      if ( tag in allowedBlocktags ) {\n        if ( m[3] || tag in singletons ) { // single?\n          const srcSlot = src.getSlot();\n          src.advance( m[0] );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            const elm = [ tag ];\n            if ( options.showOriginalLineNumber ) {\n              elm.push( addLineNumber( m[2] ? parseHtmlAttr( m[2] ) : {}, options, charPosToLine, 0, srcSlot ) );\n            }\n            else {\n              if ( m[2] ) {\n                elm.push( parseHtmlAttr( m[2] ) );\n              }\n            }\n            list.add( elm );\n            src.skipWS();\n            continue;\n          }\n        }\n        else if ( tag === 'pre' ) {\n          const t = tokenize( src, { 'pre': 1, 'code': 1 }, tag );\n          if ( options.showOriginalLineNumber ) {\n            t[0].attr = addLineNumber( t[0].attr, options, charPosToLine, 0, src.getSlot() );\n          }\n          const p = parseHtml( t, true );\n          src.load().advance( p.sourceLength );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            list.merge( p );\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else if ( tag === 'notextile' ) {\n          // merge all child elements\n          const t = tokenize( src, null, tag );\n          // it's not possible to addLineNumber here (no tag)\n          let s = 1; // start after open tag\n          while ( /^\\s+$/.test( t[s].src ) ) {\n            s++; // skip whitespace\n          }\n          const p = parseHtml( t.slice( s, -1 ), true );\n          const x = t.pop();\n          src.load().advance( x.pos + x.src.length );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            list.merge( p );\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else {\n          src.skipWS();\n          const t = tokenize( src, null, tag );\n          const srcSlot = src.getSlot();\n          const x = t.pop(); // this should be the end tag\n          let s = 1; // start after open tag\n          while ( t[s] && /^[\\n\\r]+$/.test( t[s].src ) ) {\n            s++; // skip whitespace\n          }\n          if ( x.tag === tag ) {\n            // inner can be empty\n            const inner = ( t.length > 1 ) ? src.slice( t[s].pos, x.pos ) : '';\n            src.advance( x.pos + x.src.length );\n            if ( /^\\s*(\\n|$)/.test( src ) ) {\n              let elm = [ tag ];\n              if ( options.showOriginalLineNumber ) {\n                elm.push( addLineNumber( m[2] ? parseHtmlAttr( m[2] ) : {}, options, charPosToLine, 0, srcSlot, src.getPos() - 1 ) );\n              }\n              else {\n                if ( m[2] ) {\n                  elm.push( parseHtmlAttr( m[2] ) );\n                }\n              }\n              if ( tag === 'script' || tag === 'style' ) {\n                elm.push( inner );\n              }\n              else {\n                let localCharOffset = ( ( t.length > 1 ) ? t[s].pos : 0 );\n                if ( options.showOriginalLineNumber ) {\n                  const removedSrc = inner.match( /^\\n+/ );\n                  if ( removedSrc && removedSrc[0] ) {\n                    localCharOffset += removedSrc[0].length;\n                  }\n                }\n                const innerHTML = inner.replace( /^\\n+/, '' ).replace( /\\s*$/, '' );\n                const isBlock = /\\n\\r?\\n/.test( innerHTML ) || tag === 'ol' || tag === 'ul';\n                const innerElm = isBlock\n                  ? parseFlow( innerHTML, options, charPosToLine ? charPosToLine[ srcSlot + localCharOffset ] : undefined, context )\n                  : parsePhrase( innerHTML, extend({}, options, { breaks: false }), charPosToLine, srcSlot + localCharOffset );\n                if ( isBlock || /^\\n/.test( inner ) ) {\n                  elm.push( '\\n' );\n                }\n                if ( isBlock || /\\s$/.test( inner ) ) {\n                  innerElm.push( '\\n' );\n                }\n                elm = elm.concat( innerElm );\n              }\n\n              list.add( elm );\n              src.skipWS(); // skip tailing whitespace\n              continue;\n            }\n          }\n        }\n      }\n      src.load();\n    }\n\n    // ruler\n    if ( ( m = reRuler.exec( src ) ) ) {\n      const elm = [ 'hr' ];\n      if ( options.showOriginalLineNumber ) {\n        elm.push( addLineNumber({}, options, charPosToLine, 0, src.getSlot() ) );\n      }\n      src.advance( m[0] );\n      list.add( elm );\n      continue;\n    }\n\n    // list\n    if ( ( m = testList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseList( m[0], options, charPosToLine, src.getSlot() ) );\n      continue;\n    }\n\n    // definition list\n    if ( ( m = testDefList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseDefList( m[0], options, charPosToLine, src.getSlot(), context ) );\n      continue;\n    }\n\n    // table\n    if ( ( m = testTable( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseTable( m[1], options, charPosToLine, src.getSlot() ) );\n      continue;\n    }\n\n    // paragraph\n    m = reBlockNormal.exec( src );\n    list.merge( paragraph( m[1], 'p', addLineNumber({}, options, charPosToLine, 0, src.getSlot() ), '\\n', options, charPosToLine, src.getSlot() ) );\n    src.advance( m[0] );\n  }\n\n  let hooks = linkRefs ? [ [fixLink, linkRefs] ] : [];\n  if ( options.hooks && Array.isArray( options.hooks ) ) {\n    hooks = hooks.concat( options.hooks );\n  }\n  return jsonml.applyHooks( list.get(), hooks, undefined, context );\n  // return linkRefs ? fixLinks( list.get(), linkRefs ) : list.get();\n}\n\nexports.parseFlow = parseFlow;\n","module.exports = function builder ( initArr ) {\n  const arr = Array.isArray( initArr ) ? initArr : [];\n\n  return {\n    add: function ( node ) {\n      if ( typeof node === 'string' &&\n           typeof arr[ arr.length - 1 ] === 'string' ) {\n        // join if possible\n        arr[ arr.length - 1 ] += node;\n      }\n      else if ( Array.isArray( node ) ) {\n        arr.push( node.filter( s => s !== undefined ) );\n      }\n      else if ( node ) {\n        arr.push( node );\n      }\n      return this;\n    },\n\n    merge: function ( arr ) {\n      for ( let i = 0, l = arr.length; i < l; i++ ) {\n        this.add( arr[i] );\n      }\n      return this;\n    },\n\n    linebreak: function () {\n      if ( arr.length ) {\n        this.add( '\\n' );\n      }\n    },\n\n    get: function () {\n      return arr;\n    }\n  };\n};\n","/*\n** Textile parser for JavaScript\n**\n** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n**\n*/\n\nconst merge = require( './merge' );\nconst jsonmlUtils = require( './jsonml' );\nconst { parseFlow } = require( './textile/flow' );\nconst { parseHtml } = require( './html' );\n\nfunction textile ( txt, opt, context ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // run the converter\n  return parseFlow( txt, opt, opt.lineOffset, context ).map( ( value ) => jsonmlUtils.toHTML(\n    value,\n    opt.renderers,\n    {dontEscapeContentForTags: opt.dontEscapeContentForTags},\n    context\n  ) ).join( '' );\n};\nmodule.exports = textile;\n\n// options\ntextile.defaults = {\n  // single-line linebreaks are converted to <br> by default\n  'breaks': true,\n  // by default, don't map the elements of HTML output, with the line numbers of input text\n  'showOriginalLineNumber': false,\n  // line number offset of the first char of input text, for showOriginalLineNumber option\n  'lineOffset': 0,\n  // by default, don't set a special CSS class name to each HTML element mapped to an original line number\n  'cssClassOriginalLineNumber': '',\n  // functions to apply to each JsonML node before rendering to HTML\n  'hooks': [],\n  // function called where a JsonML node is rendered to HTML\n  'renderers': {},\n  // don't escape content of this tags list\n  'dontEscapeContentForTags': []\n};\ntextile.setOptions = textile.setoptions = function ( opt ) {\n  merge( textile.defaults, opt );\n  return this;\n};\n\ntextile.parse = textile.convert = textile;\ntextile.html_parser = parseHtml;\n\ntextile.tokenize = function ( txt, opt, context ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // parse and return tree\n  return parseFlow( txt, opt, opt.lineOffset, context );\n};\ntextile.jsonml = function ( txt, opt, context ) {\n  // parse and return tree\n  return [ 'html' ].concat( textile.tokenize( txt, opt, context ) );\n};\ntextile.serialize = function ( jsonml, opt, context ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // serialize\n  return jsonmlUtils.toHTML(\n    jsonml,\n    opt.renderers,\n    {dontEscapeContentForTags: opt.dontEscapeContentForTags},\n    context\n  );\n};\n\ntextile.jsonmlUtils = jsonmlUtils;\n","// recurse the tree and swap out any \"href\" attributes\n// this uses the context as the replace dictionary so it can be fed to Array#map\nmodule.exports = function fixLink ( ml, dict ) {\n  if ( Array.isArray( ml ) ) {\n    if ( ml[0] === 'a' ) { // found a link\n      const attr = ml[1];\n      if ( typeof attr === 'object' && 'href' in attr && attr.href in dict ) {\n        attr.href = dict[attr.href];\n      }\n    }\n  }\n  return ml;\n};\n","// merge object b properties into object a, and concat class names\nmodule.exports = function mergeConcatClassName ( a, b ) {\n  if ( b ) {\n    for ( const k in b ) {\n      if ( k === 'class' ) {\n        a[ k ] = ( a[ k ] ? a[ k ] + ' ' : '' ) + b[ k ];\n      }\n      else {\n        a[ k ] = b[ k ];\n      }\n    }\n  }\n  return a;\n};\n","/* textile glyph parser */\n\nconst re = require( '../re' );\n\nconst reApostrophe = /(\\w)'(\\w)/g;\nconst reArrow = /([^-]|^)->/;\nconst reClosingDQuote = re.compile( /([^\\s[(])\"(?=$|\\s|[:punct:])/g );\nconst reClosingSQuote = re.compile( /([^\\s[(])'(?=$|\\s|[:punct:])/g );\nconst reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\nconst reDimsign = /([\\d.,]+['\"]? ?)x( ?)(?=[\\d.,]['\"]?)/g;\nconst reDoublePrime = re.compile( /(\\d*[.,]?\\d+)\"(?=\\s|$|[:punct:])/g );\nconst reEllipsis = /([^.]?)\\.{3}/g;\nconst reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\nconst reEndash = / - /g;\nconst reOpenDQuote = /\"/g;\nconst reOpenSQuote = /'/g;\nconst reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\nconst reSinglePrime = re.compile( /(\\d*[.,]?\\d+)'(?=\\s|$|[:punct:])/g );\nconst reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\nexports.parseGlyph = function parseGlyph ( src ) {\n  if ( typeof src !== 'string' ) {\n    return src;\n  }\n  // NB: order is important here ...\n  return src\n    .replace( reArrow, '$1&#8594;' )\n    .replace( reDimsign, '$1&#215;$2' )\n    .replace( reEllipsis, '$1&#8230;' )\n    .replace( reEmdash, '$1&#8212;$2' )\n    .replace( reEndash, ' &#8211; ' )\n    .replace( reTrademark, '$1&#8482;' )\n    .replace( reRegistered, '$1&#174;' )\n    .replace( reCopyright, '$1&#169;' )\n    // double quotes\n    .replace( reDoublePrime, '$1&#8243;' )\n    .replace( reClosingDQuote, '$1&#8221;' )\n    .replace( reOpenDQuote, '&#8220;' )\n    // single quotes\n    .replace( reSinglePrime, '$1&#8242;' )\n    .replace( reApostrophe, '$1&#8217;$2' )\n    .replace( reClosingSQuote, '$1&#8217;' )\n    .replace( reOpenSQuote, '&#8216;' )\n    // fractions and degrees\n    .replace( /[([]1\\/4[\\])]/, '&#188;' )\n    .replace( /[([]1\\/2[\\])]/, '&#189;' )\n    .replace( /[([]3\\/4[\\])]/, '&#190;' )\n    .replace( /[([]o[\\])]/, '&#176;' )\n    .replace( /[([]\\+\\/-[\\])]/, '&#177;' );\n};\n","/* textile list parser */\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst merge = require( '../merge' );\n\nconst { parseAttr, addLineNumber } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\n\nconst { txlisthd, txlisthd2 } = require( './re_ext' );\nre.pattern.txlisthd = txlisthd;\nre.pattern.txlisthd2 = txlisthd2;\nconst reList = re.compile( /^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's' );\nconst reItem = re.compile( /^([#*]+)([^\\0]+?)(\\n(?=[:txlisthd2:])|$)/, 's' );\nfunction listPad ( n ) {\n  let s = '\\n';\n  while ( n-- ) {\n    s += '\\t';\n  }\n  return s;\n}\n\nfunction testList ( src ) {\n  return reList.exec( src );\n}\n\nfunction parseList ( src, options, charPosToLine, charOffset ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /(^|\\r?\\n)[\\t ]+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset += removedSrc[0].length;\n    }\n  }\n  src = ribbon( src.replace( /(^|\\r?\\n)[\\t ]+/, '$1' ) );\n\n  const stack = [];\n  const currIndex = {};\n  const lastIndex = options._lst || {};\n  let itemIndex = 0;\n  let listAttr;\n  let m;\n  let n;\n  let s;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    const item = [ 'li' ];\n    const destLevel = m[1].length;\n    const type = ( m[1].substr( -1 ) === '#' ) ? 'ol' : 'ul';\n    let newLi = null;\n    let lst;\n    let par;\n    let pba;\n    let r;\n\n    // list starts and continuations\n    if ( ( n = /^(_|\\d+)/.exec( m[2] ) ) ) {\n      itemIndex = isFinite( n[1] )\n        ? parseInt( n[1], 10 )\n        : lastIndex[ destLevel ] || currIndex[ destLevel ] || 1;\n      m[2] = m[2].slice( n[1].length );\n    }\n\n    if ( ( pba = parseAttr( m[2], 'li' ) ) ) {\n      m[2] = m[2].slice( pba[0] );\n      pba = pba[1];\n    }\n\n    const pbaLineNumber = addLineNumber({}, options, charPosToLine, charOffset, src.getPos() );\n\n    // list control\n    if ( /^\\.\\s*$/.test( m[2] ) ) {\n      listAttr = pba || {};\n      src.advance( m[0] );\n      continue;\n    }\n\n    // create nesting until we have correct level\n    while ( stack.length < destLevel ) {\n      // list always has an attribute object, this simplifies first-pba resolution\n      lst = [ type, {}, listPad( stack.length + 1 ), ( newLi = [ 'li' ] ) ];\n      par = stack[ stack.length - 1 ];\n      if ( par ) {\n        par.li.push( listPad( stack.length ) );\n        par.li.push( lst );\n      }\n      stack.push({\n        ul: lst,\n        li: newLi,\n        // count attributes's found per list\n        att: 0,\n        pbaLineNumber: pbaLineNumber\n      });\n      currIndex[ stack.length ] = 1;\n    }\n\n    // remove nesting until we have correct level\n    while ( stack.length > destLevel ) {\n      r = stack.pop();\n      r.ul.push( listPad( stack.length ) );\n      // lists have a predictable structure - move pba from listitem to list\n      if ( r.att === 1 && !r.ul[3][1].substr ) {\n        merge( r.ul[1], r.ul[3].splice( 1, 1 )[ 0 ] );\n      }\n    }\n\n    // parent list\n    par = stack[ stack.length - 1 ];\n\n    if ( itemIndex ) {\n      par.ul[1].start = itemIndex;\n      currIndex[destLevel] = itemIndex;\n      // falsy prevents this from fireing until it is set again\n      itemIndex = 0;\n    }\n    if ( listAttr ) {\n      // \"more than 1\" prevent attribute transfers on list close\n      par.att = 9;\n      merge( par.ul[1], listAttr );\n      listAttr = null;\n    }\n\n    if ( !newLi ) {\n      par.ul.push( listPad( stack.length ), item );\n      par.li = item;\n    }\n    if ( pba ) {\n      par.li.push( merge( pba, pbaLineNumber ) );\n      par.att++;\n    }\n    else {\n      par.li.push( pbaLineNumber );\n    }\n    Array.prototype.push.apply( par.li, parsePhrase( m[2].trim(), options, charPosToLine, charOffset ) );\n\n    src.advance( m[0] );\n    currIndex[destLevel] = ( currIndex[destLevel] || 0 ) + 1;\n  }\n\n  // remember indexes for continuations next time\n  options._lst = currIndex;\n\n  while ( stack.length ) {\n    s = stack.pop();\n    s.ul.push( listPad( stack.length ) );\n    // lists have a predictable structure - move pba from listitem to list\n    if ( s.att === 1 && !s.ul[3][1].substr ) {\n      merge( s.ul[1], s.ul[3].splice( 1, 1 )[0] );\n    }\n    // line number should stay on listitem\n    if ( typeof ( s.ul[3][1] ) === 'object' ) {\n      merge( s.ul[3][1], s.pbaLineNumber );\n    }\n    else {\n      s.ul[3].splice( 1, 0, s.pbaLineNumber );\n    }\n  }\n\n  return s.ul;\n}\n\nmodule.exports = {\n  testList: testList,\n  parseList: parseList\n};\n","/* definitions list parser */\n\nconst ribbon = require( '../ribbon' );\n\nconst { addLineNumber } = require( './attr' );\n\nconst reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\nconst reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\nfunction testDefList ( src ) {\n  return reDeflist.exec( src );\n}\n\nfunction parseDefList ( src, options, charPosToLine, charOffset, context ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /^\\s+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset += removedSrc[0].length;\n    }\n  }\n  src = ribbon( src.trim() );\n\n  // late loading to get around the lack of non-circular-dependency support in RequireJS\n  const parsePhrase = require( './phrase' ).parsePhrase;\n  const parseFlow = require( './flow' ).parseFlow;\n\n  const deflist = [ 'dl', '\\n' ];\n  let terms;\n  let def;\n  let m;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    // add terms\n    terms = m[1].split( /(?:^|\\n)- / );\n    let localCharOffset = terms[0].length;\n    terms = terms.slice( 1 );\n    let separators = [];\n    if ( options.showOriginalLineNumber ) {\n      separators = m[1].match( /(?:^|\\n)- /g ).slice( 1 );\n    }\n    while ( terms.length ) {\n      const term = terms.shift();\n      deflist.push( '\\t'\n        , [ 'dt' ].concat(\n          addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset )\n          , parsePhrase( term.trim(), options, charPosToLine, charOffset ) )\n        , '\\n'\n      );\n      if ( options.showOriginalLineNumber ) {\n        localCharOffset += term.length;\n        // perhaps no separator at the end of the list\n        if ( separators.length ) {\n          localCharOffset += separators.shift().length;\n        }\n      }\n    }\n    // add definitions\n    def = m[2].trim();\n    if ( options.showOriginalLineNumber ) {\n      // rebase local char offset, and add +2 for ':=' between term and definition\n      localCharOffset = m[1].length + 2;\n\n      const removedSrc = m[2].match( /^\\s+/ );\n      if ( removedSrc && removedSrc[0] ) {\n        localCharOffset += removedSrc[0].length;\n      }\n    }\n    deflist.push( '\\t'\n      , [ 'dd' ].concat(\n        addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset )\n        , ( /=:$/.test( def ) )\n          ? parseFlow( def.slice( 0, -2 ).trim(), options, options.showOriginalLineNumber ? charPosToLine[ ( charOffset || 0 ) + localCharOffset + src.getPos() ] : 0, context )\n          : parsePhrase( def, options, charPosToLine, ( charOffset || 0 ) + localCharOffset + src.getPos() )\n      )\n      , '\\n'\n    );\n    src.advance( m[0] );\n  }\n  return deflist;\n}\n\nexports.testDefList = testDefList;\nexports.parseDefList = parseDefList;\n","/* textile table parser */\n\nconst re = require( '../re' );\nconst merge = require( '../merge' );\nconst ribbon = require( '../ribbon' );\n\nconst { parseAttr, addLineNumber } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\nconst { reIndent } = require( '../jsonml' );\n\nconst { txattr } = require( './re_ext' );\nre.pattern.txattr = txattr;\n\nconst reTable = re.compile( /^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n+)?/, 's' );\nconst reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\nconst reRowCapture = re.compile( /^(\\|([~^-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?(\\|)(.*?)\\|[^\\n\\S]*(\\n|$)/, 's' );\nconst reCaption = /^\\|=([^\\n+]*)\\n/;\nconst reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\nconst reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\nconst charToTag = {\n  '^': 'thead',\n  '~': 'tfoot',\n  '-': 'tbody'\n};\n\nfunction parseColgroup ( src ) {\n  const colgroup = [ 'colgroup', {} ];\n  src.split( '|' )\n    .forEach( function ( s, isCol ) {\n      const col = ( isCol ) ? {} : colgroup[ 1 ];\n      let d = s.trim();\n      let m;\n      if ( d ) {\n        if ( ( m = /^\\\\(\\d+)/.exec( d ) ) ) {\n          col.span = +m[ 1 ];\n          d = d.slice( m[ 0 ].length );\n        }\n        if ( ( m = parseAttr( d, 'col' ) ) ) {\n          merge( col, m[ 1 ] );\n          d = d.slice( m[ 0 ] );\n        }\n        if ( ( m = /\\b\\d+\\b/.exec( d ) ) ) {\n          col.width = +m[0];\n        }\n      }\n      if ( isCol ) {\n        colgroup.push( '\\n\\t\\t', [ 'col', col ] );\n      }\n    });\n  return colgroup.concat( [ '\\n\\t' ] );\n}\n\nfunction testTable ( src ) {\n  return reTable.exec( src );\n}\n\nfunction parseTable ( src, options, charPosToLine, charOffset ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /^\\s+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset += removedSrc[0].length;\n    }\n  }\n  src = ribbon( src.trim() );\n\n  const rowgroups = [];\n  let colgroup;\n  let caption;\n  const tAttr = {};\n  let tCurr;\n  let row;\n  let inner;\n  let pba;\n  let more;\n  let m;\n  let extended = 0;\n\n  const setRowGroup = function ( type, pba ) {\n    tCurr = [ type, pba || {} ];\n    rowgroups.push( tCurr );\n  };\n\n  if ( ( m = reHead.exec( src ) ) ) {\n    // parse and apply table attr\n    src.advance( m[0] );\n    pba = parseAttr( m[2], 'table' );\n    if ( pba ) {\n      merge( tAttr, pba[1] );\n    }\n    if ( m[3] ) {\n      tAttr.summary = m[3];\n    }\n  }\n\n  // caption\n  if ( ( m = reCaption.exec( src ) ) ) {\n    caption = [ 'caption' ];\n    if ( ( pba = parseAttr( m[1], 'caption' ) ) ) {\n      caption.push( pba[1] );\n      m[1] = m[1].slice( pba[0] );\n    }\n    if ( /\\./.test( m[1] ) ) { // mandatory \".\"\n      caption.push( m[1].slice( 1 ).replace( /\\|\\s*$/, '' ).trim() );\n      extended++;\n      src.advance( m[0] );\n    }\n    else {\n      caption = null;\n    }\n  }\n\n  do {\n    // colgroup\n    if ( ( m = reColgroup.exec( src ) ) ) {\n      colgroup = parseColgroup( m[1] );\n      extended++;\n    }\n    // \"rowgroup\" (tbody, thead, tfoot)\n    else if ( ( m = reRowgroup.exec( src ) ) ) {\n      // PHP allows any amount of these in any order\n      // and simply translates them straight through\n      // the same is done here.\n      const tag = charToTag[ m[1] ] || 'tbody';\n      pba = parseAttr( `${ m[2] } `, tag );\n      setRowGroup( tag, pba && pba[1] );\n      extended++;\n    }\n    // row\n    else if ( ( m = reRowCapture.exec( src ) ) ) {\n      const localCharOffset = 0 + ( m[1] ? m[1].length : 0 ) + ( m[2] ? m[2].length : 0 ) + ( m[3] ? m[3].length : 0 ) + ( m[4] ? m[4].length : 0 );\n\n      if ( !tCurr ) { setRowGroup( 'tbody' ); }\n\n      row = [ 'tr' ];\n\n      if ( m[3] && ( pba = parseAttr( m[3], 'tr' ) ) ) {\n        // FIXME: requires \"\\.\\s?\" -- else what ?\n        row.push( addLineNumber( pba[1], options, charPosToLine, charOffset, src.getPos() ) );\n      }\n      else {\n        row.push( addLineNumber({}, options, charPosToLine, charOffset, src.getPos() ) );\n      }\n\n      tCurr.push( '\\n\\t\\t', row );\n      inner = ribbon( m[5] );\n      do {\n        inner.save();\n\n        // cell loop\n        const th = inner.startsWith( '_' );\n        let cell = [ th ? 'th' : 'td' ];\n        if ( th ) {\n          inner.advance( 1 );\n        }\n\n        pba = parseAttr( inner, 'td' );\n        if ( pba ) {\n          inner.advance( pba[0] );\n          cell.push( pba[1] ); // FIXME: don't do this if next text fails\n        }\n\n        if ( pba || th ) {\n          const p = /^\\.\\s*/.exec( inner );\n          if ( p ) {\n            inner.advance( p[0] );\n          }\n          else {\n            cell = [ 'td' ];\n            inner.load();\n          }\n        }\n\n        const mx = /^(==.*?==|[^|])*/.exec( inner );\n        cell = cell.concat( parsePhrase( mx[0], options, charPosToLine, charOffset + src.getPos() + localCharOffset + inner.getPos() ) );\n        row.push( '\\n\\t\\t\\t', cell );\n        more = inner.valueOf().charAt( mx[0].length ) === '|';\n        inner.advance( mx[0].length + 1 );\n      }\n      while ( more );\n\n      row.push( '\\n\\t\\t' );\n    }\n    //\n    if ( m ) {\n      src.advance( m[0] );\n    }\n  }\n  while ( m );\n\n  // assemble table\n  let table = [ 'table', tAttr ];\n  if ( extended ) {\n    if ( caption ) {\n      table.push( '\\n\\t', caption );\n    }\n    if ( colgroup ) {\n      table.push( '\\n\\t', colgroup );\n    }\n    rowgroups.forEach( function ( tbody ) {\n      table.push( '\\n\\t', tbody.concat( [ '\\n\\t' ] ) );\n    });\n  }\n  else {\n    table = table.concat( reIndent( rowgroups[0].slice( 2 ), -1 ) );\n  }\n\n  table.push( '\\n' );\n  return table;\n}\n\nmodule.exports = {\n  parseColgroup: parseColgroup,\n  parseTable: parseTable,\n  testTable: testTable\n};\n"],"sourceRoot":""}